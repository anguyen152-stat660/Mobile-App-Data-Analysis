# -*- coding: utf-8 -*-
"""Mobile App Data Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J5YRxBsHR9N9w-WxOriZGx0dOFmHymB2
"""



"""# Mobile App Data Analysis

# I. Introduction 
The purpose of this analysis is for Anh Nguyen to revise Python syntaxs, data analysis techniques in Python and to try out Google Colab 
**About the dataset**: ....

## II. Data Exploration

II.1, Data Exploring (Simple version)
"""

import pandas as pd
url1 = 'https://raw.githubusercontent.com/anguyen152-stat660/Mobile-App-Data-Analysis/master/AppleStore.csv'
url2 = 'https://raw.githubusercontent.com/anguyen152-stat660/Mobile-App-Data-Analysis/9787cf976e548d188ad834d0f29c03bad856ae08/googleplaystore.csv'
df_apple = pd.read_csv(url1)
df_google = pd.read_csv(url2)

android = df_google.values.tolist()
ios = df_apple.values.tolist()

def explore_data (dataset, start, end, rows_and_columns = False):
  dataset_slice = dataset[start : end]
  for row in dataset_slice:
    print(row)
    print('\n')

  if rows_and_columns :
    print('Number of rows:', len(dataset))
    print('Number of columns:', len(dataset[0]))

print ('* ios dataset overview :')
print('\n')
explore_data(ios, 0, 5, rows_and_columns= True)

print('\n')

print('* android dataset overview : ')
print('\n')

explore_data(android, 0, 5, rows_and_columns=True)

"""II.2, Data Cleaning 
* Detecting and deleting wrong data
"""

# The row 10472 has the rating is 19. 
# This is off because the maximum rating for a Google Play app is 5. As a consequence, we'll delete this row.
# Detected from kaggle's discussion for this dataset 

print(android[10472])
print(android[0])

# run just once 

print(len(android))
del android[10472]
print(len(android))

"""* Removing Duplicated rows"""

duplicated_apps = []
unique_apps = []

for apps in android : 
  names = apps[0]
  if names in unique_apps : 
    duplicated_apps.append(names)
  else : 
    unique_apps.append(names)

print ('no. of duplicated apps :', len(duplicated_apps))  
print('\n')
print('examples of duplicated apps:', duplicated_apps[5:])

"""After separating the apps into 2 lists (unique and duplicated), we have to remove the duplicate rows, but do we do it randomly ? No. Let's do it based on the number of reviews (keep the rows with highest number of reviews only)"""

review_max = {}
android_clean = []
android_added = []


for rows in android : 
  name = rows[0]
  n_reviews = float(rows[3])
  
  if name in review_max and review_max[name] < n_reviews : 
    review_max[name] = n_reviews
  elif name not in review_max: 
    review_max[name] = n_reviews

print(len(review_max))

"""* Initializing two empty lists, android_clean and already_added.
* Loop through the android data set, and for every iteration:
 + isolate the name of the app and the number of reviews.
 + add the current row (app) to the android_clean list, and the app name (name) to the already_added list conditionally.
"""

android_clean = []
already_added = []

for app in android:
    name = app[0]
    n_reviews = float(app[3])
    
    if (review_max[name] == n_reviews) and (name not in already_added):
        android_clean.append(app)
        already_added.append(name)

explore_data(android_clean, 0, 3, True)

"""* Removing non-English Apps 
* Method : 
- Remove each app whose name contains a symbol that is not commonly used in English text â€” English text usually includes letters from the English alphabet, numbers composed of digits from 0 to 9, punctuation marks (., !, ?, ;, etc.), and other symbols (+, *, /, etc.).

All these characters that are specific to English texts are encoded using the ASCII standard. Each ASCII character has a corresponding number between 0 and 127 associated with it, and we can take advantage of that to build a function that checks an app name and tells us whether it contains non-ASCII characters.
"""

def is_english(string):
    
    for character in string:
        if ord(character) > 127:
            return False
    
    return True

print(is_english('Instagram'))
print(is_english('çˆ±å¥‡è‰ºPPS -ã€Šæ¬¢ä¹é¢‚2ã€‹ç”µè§†å‰§çƒ­æ’­'))

### To minimize the impact of data loss, we'll only remove an app if its name has more than three non-ASCII characters ( still keep apps with emojis)
def is_english(string):
    non_ascii = 0
    
    for character in string:
        if ord(character) > 127:
            non_ascii += 1
    
    if non_ascii > 3:
        return False
    else:
        return True

print(is_english('Docs To Goâ„¢ Free Office Suite'))
print(is_english('Instachat ðŸ˜œ'))

android_english = []
ios_english = []

for app in android_clean:
    name = app[0]
    if is_english(name):
        android_english.append(app)
        
for app in ios:
    name = app[1]
    if is_english(name):
        ios_english.append(app)
        
explore_data(android_english, 0, 3, True)
print('\n')
explore_data(ios_english, 0, 3, True)

"""* Isolating free apps"""

android_final = []
ios_final = []

for app in android_english:
    price = app[7]
    if price == '0':
        android_final.append(app)
        
for app in ios_english:
    price = app[4]
    if price == '0.0':
        ios_final.append(app)
        
print(len(android_final))
print(len(ios_final))

"""We're left with 8864 Android apps and 3222 iOS apps until this point

**MOST COMMON APPS BY GENRE **

STEPS : 
- Build a minimal Android version of the app, and add it to Google Play.
- If the app has a good response from users, we then develop it further.
- If the app is profitable after six months, we also build an iOS version of the app and add it to the App Store.

2 functions we can use to analyze the frequency tables:

1st is to generate frequency tables that show percentages
Another one is to display the percentages in a descending order
"""

def freq_table(dataset, index):
    table = {}
    total = 0
    
    for row in dataset:
        total += 1
        value = row[index]
        if value in table:
            table[value] += 1
        else:
            table[value] = 1
    
    table_percentages = {}
    for key in table:
        percentage = (table[key] / total) * 100
        table_percentages[key] = percentage 
    
    return table_percentages


def display_table(dataset, index):
    table = freq_table(dataset, index)
    table_display = []
    for key in table:
        key_val_as_tuple = (table[key], key)
        table_display.append(key_val_as_tuple)
        
    table_sorted = sorted(table_display, reverse = True)
    for entry in table_sorted:
        print(entry[1], ':', entry[0])

display_table(ios_final, -5)

display_table(android_final, 1)

display_table(android_final, -4)



"""**Most Popular Apps by Genre on the App Store**

Calculate the average number of installs for each app genre
"""

genres_ios = freq_table(ios_final, -5)

for genre in genres_ios:
    total = 0
    len_genre = 0
    for app in ios_final:
        genre_app = app[-5]
        if genre_app == genre:            
            n_ratings = float(app[5])
            total += n_ratings
            len_genre += 1
    avg_n_ratings = total / len_genre
    print(genre, ':', avg_n_ratings)

for app in ios_final:
    if app[-5] == 'Navigation':
        print(app[1], ':', app[5])

for app in ios_final:
    if app[-5] == 'Reference':
        print(app[1], ':', app[5])

categories_android = freq_table(android_final, 1)

for category in categories_android:
    total = 0
    len_category = 0
    for app in android_final:
        category_app = app[1]
        if category_app == category:            
            n_installs = app[5]
            n_installs = n_installs.replace(',', '')
            n_installs = n_installs.replace('+', '')
            total += float(n_installs)
            len_category += 1
    avg_n_installs = total / len_category
    print(category, ':', avg_n_installs)

for app in android_final:
    if app[1] == 'COMMUNICATION' and (app[5] == '1,000,000,000+'
                                      or app[5] == '500,000,000+'
                                      or app[5] == '100,000,000+'):
        print(app[0], ':', app[5])

under_100_m = []

for app in android_final:
    n_installs = app[5]
    n_installs = n_installs.replace(',', '')
    n_installs = n_installs.replace('+', '')
    if (app[1] == 'COMMUNICATION') and (float(n_installs) < 100000000):
        under_100_m.append(float(n_installs))
        
sum(under_100_m) / len(under_100_m)

for app in android_final:
    if app[1] == 'BOOKS_AND_REFERENCE':
        print(app[0], ':', app[5])

for app in android_final:
    if app[1] == 'BOOKS_AND_REFERENCE' and (app[5] == '1,000,000,000+'
                                            or app[5] == '500,000,000+'
                                            or app[5] == '100,000,000+'):
        print(app[0], ':', app[5])

for app in android_final:
    if app[1] == 'BOOKS_AND_REFERENCE' and (app[5] == '1,000,000+'
                                            or app[5] == '5,000,000+'
                                            or app[5] == '10,000,000+'
                                            or app[5] == '50,000,000+'):
        print(app[0], ':', app[5])



"""**Conclusions**

In this project, we analyzed data about the App Store and Google Play mobile apps with the goal of recommending an app profile that can be profitable for both markets.
"""